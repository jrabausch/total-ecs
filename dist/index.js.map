{"version":3,"sources":["../src/index.ts","../src/entity-manager.ts","../src/entity-query.ts","../src/events.ts","../src/index-pool.ts"],"sourcesContent":["export * from './entity-manager';\nexport * from './entity-query';\nexport * from './events';\nexport * from './index-pool';\nexport * from './interfaces';\n","import type { Component, ComponentClass, ComponentPool, Entity } from './interfaces';\nimport { EventEmitter } from '@jrabausch/event-emitter';\nimport { EntityQuery } from './entity-query';\nimport { ComponentEnterEvent, ComponentLeaveEvent } from './events';\nimport { IndexPool } from './index-pool';\n\nexport class EntityManager extends EventEmitter {\n  protected count: Entity = 0;\n  protected readonly indexPool: IndexPool;\n  protected readonly entities: { [index: number]: Entity } = {};\n  protected readonly indexes: { [entity: Entity]: number } = {};\n  protected readonly components: { [type: string]: ComponentPool<Component> } = {};\n  protected readonly queries: Map<string, EntityQuery<any>> = new Map();\n\n  constructor(\n    protected readonly emitEvents: boolean = true,\n    sortIndexes: boolean = false,\n  ) {\n    super();\n    this.indexPool = new IndexPool(sortIndexes);\n  }\n\n  createEntity(...components: Component[]): Entity {\n    const entity: Entity = ++this.count;\n    const index = this.indexPool.get();\n\n    this.entities[index] = entity;\n    this.indexes[entity] = index;\n\n    if (components.length) {\n      this.addComponent(entity, ...components);\n    }\n\n    return entity;\n  }\n\n  destroyEntity(entity: Entity): void {\n    const index = this.indexes[entity];\n\n    if (index === undefined) {\n      return;\n    }\n\n    delete this.indexes[entity];\n\n    for (const type in this.components) {\n      const component = this.components[type][index];\n\n      if (component !== undefined) {\n        this.components[type][index] = undefined;\n        this.emitEvents && this.emit(new ComponentLeaveEvent(component, entity));\n      }\n    }\n\n    delete this.entities[index];\n\n    this.indexPool.free(index);\n  }\n\n  hasEntity(entity: Entity): boolean {\n    return this.indexes[entity] !== undefined;\n  }\n\n  hasComponent(entity: Entity, componentClass: ComponentClass<Component>): boolean {\n    const index = this.indexes[entity];\n\n    if (index === undefined) {\n      throw new ReferenceError(`Entity \"${entity}\" does not exist`);\n    }\n\n    const componentPool = this.components[componentClass.name];\n\n    return componentPool ? componentPool[index] !== undefined : false;\n  }\n\n  getComponent<T extends Component>(entity: Entity, componentClass: ComponentClass<T>): T | undefined {\n    const index = this.indexes[entity];\n\n    if (index === undefined) {\n      throw new ReferenceError(`Entity \"${entity}\" does not exist`);\n    }\n\n    const componentPool = this.components[componentClass.name];\n\n    return componentPool ? componentPool[index] as T : undefined;\n  }\n\n  addComponent(entity: Entity, ...components: Component[]): void {\n    const index = this.indexes[entity];\n\n    if (index === undefined) {\n      throw new ReferenceError(`Entity \"${entity}\" does not exist`);\n    }\n\n    for (let i = 0; i < components.length; i++) {\n      const component = components[i];\n      const componentClassName = component.constructor.name;\n      let componentPool = this.components[componentClassName];\n\n      if (componentPool === undefined) {\n        componentPool = this.components[componentClassName] = [];\n      }\n\n      const currentComponent = componentPool[index];\n      componentPool[index] = component;\n\n      if (this.emitEvents) {\n        if (currentComponent !== undefined) {\n          this.emit(new ComponentLeaveEvent(currentComponent, entity));\n        }\n\n        this.emit(new ComponentEnterEvent(component, entity));\n      }\n    }\n  }\n\n  removeComponent<T extends Component>(entity: Entity, componentClass: ComponentClass<T>): T | undefined {\n    const index = this.indexes[entity];\n\n    if (index === undefined) {\n      throw new ReferenceError(`Entity \"${entity}\" does not exist`);\n    }\n\n    const componentPool = this.components[componentClass.name];\n\n    if (componentPool === undefined) {\n      return undefined;\n    }\n\n    const component = componentPool[index];\n\n    if (component === undefined) {\n      return undefined;\n    }\n\n    componentPool[index] = undefined;\n    this.emitEvents && this.emit(new ComponentLeaveEvent(component, entity));\n    return component as T;\n  }\n\n  createQuery<T extends ComponentClass<Component>, A extends T, B extends T[]>(\n    componentClass: A,\n    ...componentClasses: B\n  ): EntityQuery<[A, ...B]> {\n    const componentClassNames = [componentClass, ...componentClasses].map(c => c.name);\n    const queryName = componentClassNames.join('-');\n\n    let query = this.queries.get(queryName);\n\n    if (query !== undefined) {\n      return query;\n    }\n\n    const componentPools = componentClassNames.map((className) => {\n      let componentPool = this.components[className];\n\n      if (componentPool === undefined) {\n        componentPool = this.components[className] = [];\n      }\n\n      return componentPool;\n    });\n\n    query = new EntityQuery(componentPools, this.entities);\n    this.queries.set(queryName, query);\n\n    return query;\n  }\n}\n","import type { Component, ComponentClass, ComponentPool, Entity, QueryCallback } from './interfaces';\n\nexport class EntityQuery<T extends ComponentClass<Component>[]> {\n  protected readonly execute: (cb: QueryCallback<T>) => any;\n\n  constructor(componentPools: ComponentPool<Component>[], entityMap: { [index: number]: Entity }) {\n    const variables: string[] = [];\n    let pools = '';\n    let conditions = '';\n\n    for (let i = 0; i < componentPools.length; i++) {\n      pools += `var pool${i} = pools[${i}];\\n`;\n\n      const component = `component${i}`;\n      conditions += `var ${component} = pool${i}[index];\\n`;\n      conditions += `if(${component} === undefined) continue;\\n`;\n      variables.push(component);\n    }\n\n    const func = `\n      ${pools}\n      return function(callback){\n        var length = pool0.length;\n        var index, result;\n        for(index = 0; index < length; index++){\n          ${conditions}\n          result = callback(entities[index], ${variables.join(',')});\n          if(result !== undefined){\n            return result;\n          }\n        }\n      }\n    `;\n\n    // eslint-disable-next-line no-new-func\n    this.execute = new Function('pools', 'entities', func)(componentPools, entityMap);\n  }\n\n  run<C extends QueryCallback<T>>(callback: C): ReturnType<C> | void {\n    return this.execute(callback);\n  }\n}\n","import type { Component, Entity } from './interfaces';\n\nexport abstract class ComponentEvent<T extends Component> {\n  readonly component: T;\n  readonly entity: Entity;\n  constructor(component: T, entity: Entity) {\n    this.component = component;\n    this.entity = entity;\n  }\n}\n\nexport class ComponentEnterEvent<T extends Component> extends ComponentEvent<T> { };\nexport class ComponentLeaveEvent<T extends Component> extends ComponentEvent<T> { };\n","export class IndexPool {\n  protected count: number = 0;\n  protected readonly pending: number[] = [];\n\n  constructor(\n    protected readonly sort: boolean = false,\n  ) {\n  }\n\n  get(): number {\n    if (this.pending.length) {\n      return this.pending.pop()!;\n    }\n    return this.count++;\n  }\n\n  free(index: number): void {\n    this.pending.push(index);\n    this.sort && this.pending.sort((a, b) => b - a);\n  }\n\n  get size(): number {\n    return this.count;\n  }\n}\n"],"mappings":"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","names":[]}